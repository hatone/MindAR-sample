<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Door Usage AR Overlay</title>
  <link rel="stylesheet" href="./styles.css">
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
</head>
<body>
  <div class="overlay" id="start-overlay">
    <div class="panel">
      <h1>Door Usage AR Overlay</h1>
      <p>Tap “Start AR” and point your camera at the target door.</p>
      <p class="note">Requires camera permission. Use HTTPS on mobile; HTTP is fine for desktop testing.</p>
      <p id="asset-status" class="note warn">Checking for ./assets/door-targets.mind …</p>
      <p id="ar-status" class="note"></p>
      <button id="start-button" disabled>Start AR</button>
    </div>
  </div>

  <a-scene
    class="ar-scene"
    mindar-image="imageTargetSrc: ./assets/door-targets.mind; autoStart: false; warmupTolerance: 5; missTolerance: 10; filterMinCF: 0.0001;"
    embedded
    color-space="sRGB"
    renderer="colorManagement: true, alpha: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: false">

    <a-assets>
      <img id="door-ref" src="./assets/door-reference.jpg" crossorigin="anonymous">
    </a-assets>

    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.8; position: 0 2 1"></a-entity>

    <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

    <a-entity mindar-image-target="targetIndex: 0" scale="1.25 1.25 1.25">
      <a-plane
        position="0 0 -0.05"
        width="1.6"
        height="0.9"
        material="color: #0f172a; opacity: 0.72; transparent: true; shader: flat; side: double"
        visible="true">
      </a-plane>
      <a-text
        value="ドアの使い方：\n1. カードキーをここにタッチ\n2. ランプが緑になったら開けてください"
        align="center"
        wrap-count="24"
        width="1.4"
        color="#f8fafc"
        side="double"
        position="0 0 -0.03"
        visible="true">
      </a-text>
    </a-entity>
  </a-scene>

  <div id="debug-info" class="note"></div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const startButton = document.getElementById("start-button");
      const overlay = document.getElementById("start-overlay");
      const sceneEl = document.querySelector("a-scene");
      const assetStatus = document.getElementById("asset-status");
      const arStatus = document.getElementById("ar-status");
      const targetEntity = document.querySelector("[mindar-image-target]");
      const cameraEl = document.querySelector("a-camera");
      const textEl = document.querySelector("a-text");
      const planeEl = document.querySelector("a-plane");
      const debugInfo = document.getElementById("debug-info");

      const checkMindFile = async () => {
        try {
          const res = await fetch("./assets/door-targets.mind", { method: "HEAD" });
          if (!res.ok) throw new Error("target file missing");
          const size = res.headers.get("content-length");
          assetStatus.textContent = `Target file detected (${size ? `${(Number(size) / 1024).toFixed(1)} KB` : "size unknown"})`;
          assetStatus.classList.remove("warn");
          startButton.disabled = false;
        } catch (err) {
          assetStatus.textContent = "Missing: ./assets/door-targets.mind — generate with the MindAR Image Target Compiler and place it under /web/assets.";
          assetStatus.classList.add("warn");
          startButton.disabled = true;
        }
      };
      checkMindFile();

      const ensureCameraAccess = async () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Camera API unsupported. Use a modern browser.");
        }
        const constraints = {
          video: { facingMode: { ideal: "environment" } },
          audio: false
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        // stop immediately; MindAR will request again
        stream.getTracks().forEach((t) => t.stop());
      };

      const waitForMindAR = () =>
        new Promise((resolve, reject) => {
          const ready = () => {
            const system = sceneEl.systems && sceneEl.systems["mindar-image-system"];
            if (system && typeof system.start === "function") {
              resolve(system);
            } else {
              reject(new Error("MindAR system not initialized"));
            }
          };
          if (sceneEl.systems && sceneEl.systems["mindar-image-system"] && typeof sceneEl.systems["mindar-image-system"].start === "function") {
            resolve(sceneEl.systems["mindar-image-system"]);
          } else {
            const timeout = setTimeout(() => reject(new Error("MindAR system init timeout")), 8000);
            sceneEl.addEventListener(
              "renderstart",
              () => {
                clearTimeout(timeout);
                ready();
              },
              { once: true }
            );
          }
        });

      const startAR = async () => {
        arStatus.textContent = "Starting AR…";
        try {
          await ensureCameraAccess();
          if (!sceneEl.hasLoaded) {
            await new Promise((resolve) => sceneEl.addEventListener("loaded", resolve, { once: true }));
          }
          const mindarSystem = await waitForMindAR();
          await mindarSystem.start();
          if (mindarSystem.video) {
            mindarSystem.video.setAttribute("playsinline", "true");
            mindarSystem.video.classList.add("mindar-video");
            mindarSystem.video.style.zIndex = "0";
          }
          if (cameraEl?.getObject3D("camera")) {
            const camObj = cameraEl.getObject3D("camera");
            camObj.near = 0.01;
            camObj.far = 1000;
            camObj.updateProjectionMatrix();
          }
          overlay.classList.add("hidden");
          arStatus.textContent = "";
        } catch (err) {
          arStatus.textContent = `Failed to start AR: ${err?.message || "Camera blocked"}. Please allow camera access and reload.`;
          console.error("AR start error", err);
        }
      };

      sceneEl.addEventListener("arReady", () => {
        arStatus.textContent = "Camera ready. Point at the door target.";
      });

      sceneEl.addEventListener("arError", (e) => {
        arStatus.textContent = "Camera access was blocked. Please allow camera and reload.";
        console.error("AR error", e);
      });

      if (targetEntity) {
        targetEntity.addEventListener("loaded", () => {
          targetEntity.object3D.traverse((obj) => {
            obj.frustumCulled = false;
            if (obj.material) obj.renderOrder = 2;
          });
          if (planeEl) {
            planeEl.setAttribute("material", {
              color: "#0f172a",
              opacity: 0.72,
              transparent: true,
              shader: "flat",
              side: "double",
              depthTest: false
            });
            if (planeEl.object3D) planeEl.object3D.renderOrder = 10;
          }
          if (textEl?.object3D) {
            textEl.object3D.renderOrder = 11;
            textEl.object3D.frustumCulled = false;
          }
        });
        targetEntity.addEventListener("targetFound", (e) => {
          console.log("FOUND", e);
          targetEntity.object3D.visible = true;
          const sceneRenderer = sceneEl.renderer;
          if (cameraEl?.components?.camera?.camera) {
            const cam = cameraEl.components.camera.camera;
            console.log("Camera:", cameraEl.object3D.position, cam.near, cam.far);
            console.log("Camera proj[0..3]:", cam.projectionMatrix.elements.slice(0, 4));
            console.log("Camera world pos:", cameraEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
            console.log("Camera quaternion:", cameraEl.object3D.quaternion);
          }
          if (targetEntity?.object3D) {
            console.log("Target visible:", targetEntity.object3D.visible);
            console.log("Target position:", targetEntity.object3D.position);
            console.log("Target scale:", targetEntity.object3D.scale);
            console.log("Target world pos:", targetEntity.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
            console.log("Target world matrix[12..15]:", targetEntity.object3D.matrixWorld.elements.slice(12, 16));
            console.log("Target quaternion:", targetEntity.object3D.quaternion);
          }
          if (textEl?.object3D) {
            console.log("Text visible:", textEl.object3D.visible);
            console.log("Text position:", textEl.object3D.position);
            console.log("Text world pos:", textEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
            console.log("Text quaternion:", textEl.object3D.quaternion);
          }
          if (planeEl?.object3D) {
            console.log("Plane visible:", planeEl.object3D.visible);
            console.log("Plane position:", planeEl.object3D.position);
            console.log("Plane world pos:", planeEl.object3D.getWorldPosition(new AFRAME.THREE.Vector3()));
            console.log("Plane quaternion:", planeEl.object3D.quaternion);
            console.log("Plane world matrix[12..15]:", planeEl.object3D.matrixWorld.elements.slice(12, 16));
          }
          if (sceneRenderer) {
            console.log("Renderer:", sceneRenderer.sortObjects, sceneRenderer.autoClear);
          }
          if (debugInfo) {
            const tgtPos = targetEntity?.object3D?.position;
            const txtPos = textEl?.object3D?.position;
            const plPos = planeEl?.object3D?.position;
            debugInfo.textContent = `Cam z:${cameraEl?.object3D?.position?.z ?? "?"} tgt z:${tgtPos?.z ?? "?"} text z:${txtPos?.z ?? "?"} plane z:${plPos?.z ?? "?"}`;
          }
          arStatus.textContent = "Door detected. Overlay locked.";
        });
        targetEntity.addEventListener("targetLost", () => {
          targetEntity.object3D.visible = false;
          arStatus.textContent = "Searching for the door target…";
        });
      }

      startButton.addEventListener("click", async () => {
        await startAR();
      });
    });
  </script>
</body>
</html>
